<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Auto-Evoluci√≥n ‚Äì Autos que aprenden la pista (Vanilla JS)</title>
  <style>
    :root{
      --bg:#0f172a; /* slate-900 */
      --panel:#0b1222;
      --panel2:#111827; /* slate-800 */
      --text:#e5e7eb; /* slate-200 */
      --muted:#94a3b8; /* slate-400 */
      --brand:#6366f1; /* indigo-500 */
      --ok:#10b981; /* emerald-500 */
      --blue:#3b82f6; /* blue-500 */
      --rose:#f43f5e; /* rose-500 */
      --road:#0b1222; /* darker road */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
    .header{position:sticky;top:0;z-index:10;display:flex;justify-content:space-between;align-items:center;padding:12px 16px;background:rgba(15,23,42,.9);backdrop-filter:blur(6px);border-bottom:1px solid #0b1222}
    .muted{color:var(--muted)}
    .main{display:grid;grid-template-columns:1fr 360px;gap:16px;padding:12px}
    @media (max-width: 1024px){.main{grid-template-columns:1fr}}
    .canvas-pane{position:relative;min-height:62vh;height:78vh;border:1px solid #0b1222;border-radius:16px;overflow:hidden;box-shadow:0 10px 24px rgba(0,0,0,.3)}
    canvas{width:100%;height:100%;display:block;cursor:crosshair}
    .btn{background:rgba(30,41,59,.8);color:var(--text);border:none;border-radius:12px;padding:8px 12px;cursor:pointer;box-shadow:0 6px 16px rgba(0,0,0,.25)}
    .btn:hover{background:#334155}
    .btn-primary{background:var(--brand)}.btn-primary:hover{background:#7c82f7}
    .hud{position:absolute;left:8px;top:8px;display:flex;gap:8px;align-items:center}
    .stats{position:absolute;right:8px;top:8px;font-size:12px;color:#d1d5db;background:rgba(30,41,59,.7);border-radius:12px;padding:3px 8px;box-shadow:0 6px 16px rgba(0,0,0,.25)}
    .dock{position:absolute;left:8px;bottom:8px;background:rgba(30,41,59,.6);border-radius:12px;padding:8px 10px;display:flex;gap:16px;align-items:center}
    .control-pane{position:sticky;top:56px;align-self:start;display:flex;flex-direction:column;gap:12px}
    .card{background:rgba(17,24,39,.7);border:1px solid #0b1222;border-radius:16px;padding:12px;box-shadow:0 10px 24px rgba(0,0,0,.25)}
    .card h3{margin:0 0 8px 0;font-size:14px}
    .row{display:flex;justify-content:space-between;align-items:center;font-size:12px;margin-bottom:6px}
    .range{width:100%}
    details{margin-top:6px}
    .checkpoint{mix-blend-mode:screen}
  </style>
</head>
<body>
  <header class="header">
    <div style="display:flex;gap:12px;align-items:center">
      <div style="font-weight:700;font-size:18px">Auto‚ÄëEvoluci√≥n üöóüß¨</div>
      <div class="muted" style="font-size:13px">Autos que aprenden a recorrer una pista</div>
    </div>
    <div class="muted" style="font-size:12px">Drag para mirar; Enter: siguiente gen; R: reset</div>
  </header>

  <main class="main">
    <section class="canvas-pane" id="canvas-pane">
      <canvas id="sim"></canvas>
      <div class="hud">
        <button id="btn-toggle" class="btn">Pausar</button>
        <button id="btn-reset" class="btn">Reset</button>
        <button id="btn-next" class="btn btn-primary">Forzar nueva gen</button>
      </div>
      <div class="stats" id="stats">‚Äî</div>
      <div class="dock">
        <label class="muted" style="display:flex;align-items:center;gap:8px;font-size:13px">
          <span>Velocidad</span>
          <input id="speed" class="range" type="range" min="1" max="12" step="1" value="8" />
        </label>
        <label class="muted" style="display:flex;align-items:center;gap:8px;font-size:13px">
          <span>Fricci√≥n</span>
          <input id="fric" class="range" type="range" min="0" max="0.2" step="0.005" value="0.02" />
        </label>
      </div>
    </section>

    <aside class="control-pane">
      <section class="card">
        <h3>Par√°metros gen√©ticos</h3>
        <div class="row"><span class="muted">Poblaci√≥n</span><span id="lbl-pop">240</span></div>
        <input id="populationSize" class="range" type="range" min="50" max="800" step="10" value="240" />
        <div class="row"><span class="muted">Pasos por genoma</span><span id="lbl-steps">600</span></div>
        <input id="geneSteps" class="range" type="range" min="200" max="1200" step="20" value="600" />
        <div class="row"><span class="muted">Mutaci√≥n</span><span id="lbl-mutation">0.050</span></div>
        <input id="mutationRate" class="range" type="range" min="0" max="0.2" step="0.005" value="0.05" />
        <div class="row"><span class="muted">Elitismo</span><span id="lbl-elitism">8</span></div>
        <input id="elitism" class="range" type="range" min="0" max="30" step="1" value="8" />
        <div class="muted" style="font-size:12px;margin-top:6px">Cambiar poblaci√≥n o pasos reinicia la simulaci√≥n.</div>
      </section>

      <section class="card">
        <h3>Pista</h3>
        <div class="row"><span class="muted">Tipo</span>
          <select id="trackType" style="background:#111827;color:#e5e7eb;border:1px solid #0b1222;border-radius:8px;padding:4px 8px">
            <option value="oval">√ìvalo</option>
            <option value="s">S‚Äëcurve</option>
            <option value="ocho">Figura 8</option>
          </select>
        </div>
        <div class="row"><span class="muted">Ancho (px)</span><span id="lbl-width">70</span></div>
        <input id="trackWidth" class="range" type="range" min="40" max="120" step="2" value="70" />
        <div class="muted" style="font-size:12px;margin-top:6px">La meta es completar la vuelta pasando por los checkpoints.</div>
      </section>

      <section class="card">
        <h3>Ayuda</h3>
        <ul class="muted" style="font-size:13px;line-height:1.5">
          <li>Los genes controlan <em>direcci√≥n</em> (giro) y <em>acelerador</em>.</li>
          <li>Fitness = % de pista recorrida (progreso sobre el trazado).</li>
          <li>Sub√≠ Mutaci√≥n al principio, bajala cuando empiecen a mejorar.</li>
        </ul>
      </section>

      <section class="card">
        <h3>Tests</h3>
        <details>
          <summary class="muted" style="cursor:pointer">Ver resultados en consola</summary>
          <div class="muted" style="font-size:12px">Se ejecutan al cargar (console.assert).</div>
        </details>
      </section>
    </aside>
  </main>

  <script>
  // =================== Utilidades ===================
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp = (a,b,t)=>a+(b-a)*t;
  function randn(mu=0,sigma=1){let u=0,v=0;while(u===0)u=Math.random();while(v===0)v=Math.random();const z=Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);return mu+z*sigma}
  function safeFmt(v,d=0){return (typeof v==='number' && Number.isFinite(v))? v.toFixed(d) : '‚Äî'}

  function pointSegNearest(px,py,x1,y1,x2,y2){
    const vx=x2-x1, vy=y2-y1; const wx=px-x1, wy=py-y1; const c1=vx*wx+vy*wy; const c2=vx*vx+vy*vy+1e-9;
    const t=clamp(c1/c2,0,1); const nx=x1+t*vx, ny=y1+t*vy; const dx=px-nx, dy=py-ny; return {dist:Math.hypot(dx,dy), t, nx, ny};
  }

  function polylineStats(pts){
    const segs=[]; let len=0; const cum=[0];
    for(let i=0;i<pts.length-1;i++){ const a=pts[i], b=pts[i+1]; const L=Math.hypot(b.x-a.x,b.y-a.y); segs.push({a,b,L}); len+=L; cum.push(len); }
    return {segs, len, cum};
  }

  // Versi√≥n cerrada: agrega segmento del √∫ltimo punto al primero (pista tipo "tubo" cerrado)
  function polylineStatsClosed(pts){
    const segs=[]; let len=0; const cum=[0];
    if (pts.length < 2) return { segs, len: 0, cum: [0] };
    for(let i=0;i<pts.length-1;i++){ const a=pts[i], b=pts[i+1]; const L=Math.hypot(b.x-a.x,b.y-a.y); segs.push({a,b,L}); len+=L; cum.push(len); }
    const a=pts[pts.length-1], b=pts[0]; const L=Math.hypot(b.x-a.x,b.y-a.y); segs.push({a,b,L}); len+=L; cum.push(len);
    return { segs, len, cum };
  }

  function nearestOnPolyline(p, stats){
    let best={dist:Infinity, segIdx:0, t:0, s:0, nx:p.x, ny:p.y};
    for(let i=0;i<stats.segs.length;i++){
      const s=stats.segs[i]; const n=pointSegNearest(p.x,p.y,s.a.x,s.a.y,s.b.x,s.b.y);
      if(n.dist<best.dist){ best={dist:n.dist, segIdx:i, t:n.t, s:stats.cum[i]+n.t*s.L, nx:n.nx, ny:n.ny}; }
    }
    return best;
  }

  function pickColor(i){const p=["#60a5fa","#22c55e","#f59e0b","#e879f9","#a78bfa","#34d399","#f97316","#fb7185"];return p[i%p.length]}

  // =================== Estado global ===================
  const canvas=document.getElementById('sim');
  const pane=document.getElementById('canvas-pane');
  const statsEl=document.getElementById('stats');

  // Gen√©tica/Sim
  let running=true;
  let populationSize=240;
  let geneSteps=600;
  let mutationRate=0.05;
  let elitism=8;

  // Auto
  let speedMultiplier=8; // slider "velocidad" (cu√°ntos steps por frame)
  let baseFriction=0.02;

  // Auto (geometr√≠a)
  const CAR_SIDE = 10; // px
  const CAR_RADIUS = Math.SQRT2 * CAR_SIDE / 2; // radio circunscrito (~7.07 para side=10)

  // Medici√≥n
  let generation=1; let stepIndex=0; let bestProgress=0; let finishedCount=0; let aliveCount=0;

  // Pista
  let trackWidth=70; let trackType='oval';
  let trackPts=[]; let trackStats=null; let trackLen=1; let checkpoints=[];

  // Poblaci√≥n
  /** @type {Array<{x:number,y:number,a:number,v:number,alive:boolean,done:boolean,step:number,genome:Array<{steer:number,throttle:number}>,fitness:number,color:string,trail:Array<{x:number,y:number}>,trailAge:number,progress:number,chk:number,onTrackTicks:number,centerSum:number,offTicks:number}>} */
  let pop=[];

  // =================== Pista ===================
  const TRACK_TEMPLATES={
    oval:(w,h)=>[[0.18,0.80],[0.30,0.87],[0.70,0.87],[0.84,0.80],[0.84,0.20],[0.70,0.13],[0.30,0.13],[0.18,0.20]].map(([x,y])=>({x:x*w,y:y*h})),
    s:(w,h)=>[[0.15,0.80],[0.35,0.70],[0.65,0.90],[0.85,0.70],[0.65,0.50],[0.35,0.30],[0.15,0.20]].map(([x,y])=>({x:x*w,y:y*h})),
    ocho:(w,h)=>[[0.20,0.75],[0.45,0.75],[0.55,0.25],[0.80,0.25],[0.55,0.75],[0.20,0.25]].map(([x,y])=>({x:x*w,y:y*h})),
  };

  function buildTrack(){
    const r=pane.getBoundingClientRect(); let w=r.width||960, h=r.height||640;
    trackPts=TRACK_TEMPLATES[trackType](w,h);
    trackStats=polylineStatsClosed(trackPts);
    trackLen=trackStats.len;
    // checkpoints: cada ~10% del largo
    checkpoints=[]; const step=trackLen/10; let acc=0, idx=0;
    for(let i=0;i<trackStats.segs.length;i++){
      const s=trackStats.segs[i]; let used=0;
      while(acc+step<=trackStats.cum[i]+s.L+1e-6){
        const t=(acc+step-trackStats.cum[i])/s.L; const x=lerp(s.a.x,s.b.x,t), y=lerp(s.a.y,s.b.y,t); checkpoints.push({x,y,r:Math.max(10,trackWidth*0.45)}); acc+=step; used++;
      }
      if(i===0 && checkpoints.length===0){
        // ensure first
        checkpoints.push({x:s.a.x,y:s.a.y,r:Math.max(10,trackWidth*0.45)});
      }
      idx+=used;
    }
  }

  // =================== Genomas (autos) ===================
  function createGenome(n){
    const g=new Array(n);
    for(let i=0;i<n;i++) g[i]={steer:(Math.random()*2-1), throttle:Math.random()};
    return g;
  }
  function cloneGenome(g){return g.map(v=>({steer:v.steer, throttle:v.throttle}))}
  function mutateGenome(g, rate, sigma=0.25){
    for(let i=0;i<g.length;i++) if(Math.random()<rate){
      const v=g[i]; v.steer=clamp(v.steer+randn(0,sigma),-1,1); v.throttle=clamp(v.throttle+randn(0,sigma*0.6),0,1);
    }
  }
  function crossover(g1,g2){ const out=new Array(g1.length); for(let i=0;i<g1.length;i++) out[i]=Math.random()<0.5?{...g1[i]}:{...g2[i]}; return out; }

  // =================== Seed / Evoluci√≥n ===================
  function seedPopulation(genomes){
    const start = trackPts[0]; const next = trackPts[1]||{x:start.x+1,y:start.y};
    const ang = Math.atan2(next.y-start.y, next.x-start.x);
    pop.length=0; bestProgress=0; finishedCount=0; stepIndex=0;
    for(let i=0;i<populationSize;i++){
      const g = genomes? cloneGenome(genomes[i%genomes.length]) : createGenome(geneSteps);
      pop.push({x:start.x, y:start.y, a:ang, v:0, alive:true, done:false, step:0, genome:g, fitness:0, color:pickColor(i), trail:[], trailAge:0, progress:0, chk:0, onTrackTicks:0, centerSum:0, offTicks:0});
    }
  }

  function evolve(){
    // fitness = mejor progreso alcanzado a lo largo del episodio
    const len = checkpoints.length || 1;
    for (const a of pop) {
      const progressScore = (a.chk || 0) / len; // progreso por checkpoints
      const onTrackScore = (a.onTrackTicks || 0) / geneSteps; // tiempo en pista
      const centerScore = (a.centerSum || 0) / Math.max(1, (a.onTrackTicks || 0)); // qu√© tan centrado estuvo
      a.fitness = progressScore * 5 + onTrackScore * 0.5 + centerScore * 0.5; // progreso domina
    }

    const totalFit = pop.reduce((s,a)=>s+a.fitness,0) || 1;
    const pick = ()=>{let r=Math.random()*totalFit; for(const a of pop){ r-=a.fitness; if(r<=0) return a;} return pop[pop.length-1]};

    const sorted=[...pop].sort((A,B)=>B.fitness-A.fitness);
    const next=[];
    for(let i=0;i<Math.min(elitism,sorted.length);i++) next.push(newCarFromGenome(cloneGenome(sorted[i].genome)));
    while(next.length<populationSize){ const p1=pick(), p2=pick(); const child=crossover(p1.genome,p2.genome); mutateGenome(child, mutationRate); next.push(newCarFromGenome(child)); }
    pop=next; generation++; stepIndex=0; finishedCount=0; bestProgress=0;
  }

  function newCarFromGenome(genome){
    const start = trackPts[0]; const next = trackPts[1]||{x:start.x+1,y:start.y};
    const ang = Math.atan2(next.y-start.y, next.x-start.x);
    return {x:start.x,y:start.y,a:ang,v:0,alive:true,done:false,step:0,genome,fitness:0,color:pickColor(Math.floor(Math.random()*9999)),trail:[],trailAge:0,progress:0, chk:0, onTrackTicks:0, centerSum:0, offTicks:0};
  }

  // =================== Simulaci√≥n ===================
  let last=performance.now(); let rafId=0;
  function loop(){
    try{
      const now=performance.now(); const dt=Math.min(0.04,(now-last)/1000); last=now;
      if(running){ for(let s=0;s<speedMultiplier;s++) step(dt); }
      render(); rafId=requestAnimationFrame(loop);
    }catch(err){ console.error('[AutoEvo] Loop error',err); cancelAnimationFrame(rafId); statsEl.textContent='Error: '+(err?.message||err); }
  }

  function step(dt){
    const W=canvas.clientWidth, H=canvas.clientHeight; if(!W||!H) return;
    aliveCount=0;
    for(const a of pop){
      if(!a.alive || a.done) continue; aliveCount++;
      const g=a.genome[a.step] || {steer:0, throttle:0};
      // Din√°mica simple de auto (no-slip):
      const maxSteer=3.0; // rad/s (subido para tomar curvas)
      const maxAccel=220; // px/s^2 (un poco m√°s de empuje)
      const maxSpeed=340; // px/s
      const fric=baseFriction; // lineal

      a.a += g.steer * maxSteer * dt;
      a.v += (g.throttle * maxAccel - fric*a.v) * dt;
      a.v = clamp(a.v, 0, maxSpeed);
      a.x += Math.cos(a.a) * a.v * dt;
      a.y += Math.sin(a.a) * a.v * dt;

      // Progreso por checkpoints + m√©trica de pista
      const near = nearestOnPolyline({x:a.x,y:a.y}, trackStats);
      // contador de tiempo dentro de pista y centrado
      // margen efectivo: mitad del ancho menos el radio del auto y el semigrosor del borde (~2px)
      const limit = Math.max(0, trackWidth*0.5 - CAR_RADIUS);
      if ( near.dist < limit ) {
        a.onTrackTicks++;
        const centeriness = 1 - clamp(near.dist / (trackWidth*0.5 + 1e-6), 0, 1);
        a.centerSum += centeriness;
      } else {
        // Toc√≥ la l√≠nea/borde del tubo: desaparece
        a.alive = false;
        continue;
      }

      // checkpoint actual
      const cp = checkpoints[a.chk];
      if (cp) {
        const dx=a.x-cp.x, dy=a.y-cp.y;
        if (dx*dx + dy*dy <= cp.r*cp.r) {
          a.chk++;
        }
      }
      // progreso normalizado (fallback: proyecci√≥n sobre polil√≠nea)
      const chkFrac = (a.chk || 0) / Math.max(1, checkpoints.length);
      const projFrac = near.s / trackLen;
      a.progress = Math.max(a.progress, chkFrac, projFrac * 0.7);
      if (a.chk >= checkpoints.length) { a.done = true; finishedCount++; }

      // Off‚Äëtrack duro solo si se aleja mucho tiempo
      
      

      a.step++; if(a.step>=geneSteps) a.alive=false;
      bestProgress = Math.max(bestProgress, a.progress);
    }
    stepIndex++;
    // Termina gen si todos murieron o llegamos al l√≠mite
    if(aliveCount===0 || stepIndex>=geneSteps+2) evolve();
  }

  // =================== Render ===================
  function render(){
    const ctx=canvas.getContext('2d'); const w=canvas.clientWidth, h=canvas.clientHeight; if(!w||!h) return; ctx.clearRect(0,0,w,h);
    // Fondo cuadriculado leve
    ctx.save(); ctx.globalAlpha=.22; ctx.strokeStyle="#0f172a"; for(let x=0;x<w;x+=40){ ctx.beginPath(); ctx.moveTo(x+.5,0); ctx.lineTo(x+.5,h); ctx.stroke(); } for(let y=0;y<h;y+=40){ ctx.beginPath(); ctx.moveTo(0,y+.5); ctx.lineTo(w,y+.5); ctx.stroke(); } ctx.restore();

    // Pista (solo calzada, sin l√≠neas de borde)
    if(trackPts.length>1){
      ctx.lineJoin='round'; ctx.lineCap='round';
      // Color contrastado con el fondo para que se vea SIEMPRE
      const roadColor = '#1f2937'; // slate-800 (m√°s claro que el fondo)
      ctx.strokeStyle = roadColor;
      ctx.lineWidth = Math.max(4, trackWidth);
      ctx.beginPath();
      ctx.moveTo(trackPts[0].x,trackPts[0].y);
      for(let i=1;i<trackPts.length;i++) ctx.lineTo(trackPts[i].x,trackPts[i].y);
      ctx.closePath();
      ctx.stroke();
    }

    // Inicio
    const s=trackPts[0], n=trackPts[1]||s; ctx.beginPath(); ctx.arc(s.x,s.y,7,0,Math.PI*2); ctx.fillStyle='#3b82f6'; ctx.fill();

    // Trails y autos
    for(const a of pop){
      ctx.save(); ctx.translate(a.x,a.y); ctx.rotate(a.a);
      // Auto: cuadradito (orientado con la direcci√≥n)
      ctx.fillStyle = a.done ? '#10b981' : a.alive ? a.color : '#64748b';
      ctx.fillRect(-CAR_SIDE/2, -CAR_SIDE/2, CAR_SIDE, CAR_SIDE);
      // Indicador sutil del frente (l√≠nea corta)
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(CAR_SIDE/2, -CAR_SIDE*0.25);
      ctx.lineTo(CAR_SIDE/2, CAR_SIDE*0.25);
      ctx.stroke();
      ctx.restore();
    }

    // Stats
    const progPct = Math.round((bestProgress||0)*100);
    statsEl.textContent = `Gen ${generation} ¬∑ Paso ${stepIndex} / ${geneSteps} ¬∑ En pista ${aliveCount} ¬∑ Mejor ${progPct}% ¬∑ Completaron ${finishedCount}`;
  }

  // =================== Layout/Boot ===================
  function resize(){
    const rect=pane.getBoundingClientRect(); let w=rect.width||960, h=rect.height||640; const dpr=Math.min(window.devicePixelRatio||1,2);
    canvas.width=Math.floor(w*dpr); canvas.height=Math.floor(h*dpr); const ctx=canvas.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0);
    buildTrack();
  }
  new ResizeObserver(resize).observe(document.documentElement);
  resize();
  seedPopulation();
  render();
  setTimeout(()=>{ if(!canvas.clientWidth||!canvas.clientHeight){ resize(); render(); } },60);
  loop();

  // =================== Controles ===================
  document.getElementById('btn-toggle').addEventListener('click',()=>{ running=!running; document.getElementById('btn-toggle').textContent=running?'Pausar':'Reanudar'; });
  document.getElementById('btn-reset').addEventListener('click',()=>{ generation=1; seedPopulation(); });
  document.getElementById('btn-next').addEventListener('click',()=>evolve());

  // Sliders
  bindRange('speed', v=>{ speedMultiplier=v; });
  bindRange('fric', v=>{ baseFriction=v; });
  bindRange('populationSize', v=>{ populationSize=v; document.getElementById('lbl-pop').textContent=v; generation=1; seedPopulation(); });
  bindRange('geneSteps', v=>{ geneSteps=v; document.getElementById('lbl-steps').textContent=v; generation=1; seedPopulation(); });
  bindRange('mutationRate', v=>{ mutationRate=v; document.getElementById('lbl-mutation').textContent=(+v).toFixed(3); });
  bindRange('elitism', v=>{ elitism=v; document.getElementById('lbl-elitism').textContent=v; });
  bindRange('trackWidth', v=>{ trackWidth=v; document.getElementById('lbl-width').textContent=v; render(); });
  document.getElementById('trackType').addEventListener('change', (e)=>{ trackType=e.target.value; buildTrack(); seedPopulation(); });

  function bindRange(id,on){ const el=document.getElementById(id); const parse=el.step&&el.step.indexOf('.')>-1?parseFloat:(v)=>parseInt(v,10); el.addEventListener('input',()=>on(parse(el.value))); }

  // =================== Tests m√≠nimos ===================
  (function runTests(){
    console.group('%cTests','color:#22c55e');
    // 1) nearest de segmento
    const n=pointSegNearest(5,0,0,0,10,0); console.assert(Math.abs(n.dist-0)<1e-6 && Math.abs(n.t-0.5)<1e-6,'nearest segmento medio');
    // 2) polylineStats
    const st=polylineStats([{x:0,y:0},{x:3,y:0},{x:3,y:4}]); console.assert(Math.abs(st.len-7)<1e-6,'len 3+4=7');
    // 3) progreso a 50%
    const st2=polylineStats([{x:0,y:0},{x:10,y:0}]); const near=nearestOnPolyline({x:5,y:2},st2); console.assert(Math.abs(near.s/st2.len-0.5)<1e-6,'s 50%');
    console.groupEnd();
  })();
  </script>
</body>
</html>
